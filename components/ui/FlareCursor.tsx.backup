'use client';

import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
  motion,
  useMotionValue,
  useSpring,
  AnimatePresence,
  useTransform
} from 'framer-motion';

interface CursorTrail {
  id: number;
  x: number;
  y: number;
  timestamp: number;
  opacity: number;
}

interface MagneticElement {
  element: HTMLElement;
  rect: DOMRect;
  magneticStrength: number;
}

const FlareCursor = () => {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isPointer, setIsPointer] = useState(false);
  const [isClicking, setIsClicking] = useState(false);
  const [isClient, setIsClient] = useState(false);
  const [trails, setTrails] = useState<CursorTrail[]>([]);
  const [cursorVariant, setCursorVariant] = useState<
    'default' | 'hover' | 'click' | 'magnetic' | 'text'
  >('default');
  const [isHoveringText, setIsHoveringText] = useState(false);
  const [magneticTarget, setMagneticTarget] = useState<{
    x: number;
    y: number;
  } | null>(null);
  const [cursorSize, setCursorSize] = useState(32);

  const cursorX = useMotionValue(0);
  const cursorY = useMotionValue(0);

  // Enhanced spring animations with different configs for different states
  const springConfig = {
    default: { stiffness: 500, damping: 28, mass: 0.5 },
    magnetic: { stiffness: 200, damping: 15, mass: 0.3 },
    text: { stiffness: 400, damping: 25, mass: 0.4 },
    click: { stiffness: 800, damping: 35, mass: 0.2 }
  };

  const currentConfig = isClicking
    ? springConfig.click
    : isHoveringText
    ? springConfig.text
    : magneticTarget
    ? springConfig.magnetic
    : springConfig.default;

  const springX = useSpring(cursorX, currentConfig);
  const springY = useSpring(cursorY, currentConfig);

  // Transform for magnetic effect
  const magneticX = useTransform(springX, (value) =>
    magneticTarget ? magneticTarget.x : value
  );
  const magneticY = useTransform(springY, (value) =>
    magneticTarget ? magneticTarget.y : value
  );

  const trailIdRef = useRef(0);
  const lastTrailTime = useRef(0);

  // Enhanced trail creation with variable opacity
  const addTrail = useCallback(
    (x: number, y: number, opacity: number = 0.6) => {
      const now = Date.now();
      if (now - lastTrailTime.current < 16) return; // Limit to 60fps

      lastTrailTime.current = now;

      const newTrail: CursorTrail = {
        id: trailIdRef.current++,
        x,
        y,
        timestamp: now,
        opacity
      };

      setTrails((prev) => {
        const filtered = prev.filter(
          (trail) => Date.now() - trail.timestamp < 400
        );
        return [...filtered, newTrail].slice(-12); // Keep last 12 trails
      });
    },
    []
  );

  // Enhanced magnetic detection
  const findMagneticElement = useCallback(
    (x: number, y: number): MagneticElement | null => {
      const magneticSelectors = [
        'button',
        'a',
        '[data-magnetic]',
        '.nav-item',
        '.btn',
        '[role="button"]'
      ];

      for (const selector of magneticSelectors) {
        const elements = document.querySelectorAll(selector);
        for (const element of Array.from(elements)) {
          const htmlElement = element as HTMLElement;
          const rect = htmlElement.getBoundingClientRect();
          const magneticRange = 50; // Magnetic attraction range

          if (
            x >= rect.left - magneticRange &&
            x <= rect.right + magneticRange &&
            y >= rect.top - magneticRange &&
            y <= rect.bottom + magneticRange
          ) {
            return {
              element: htmlElement,
              rect,
              magneticStrength: htmlElement.dataset.magneticStrength
                ? parseFloat(htmlElement.dataset.magneticStrength)
                : 0.3
            };
          }
        }
      }
      return null;
    },
    []
  );

  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      const newX = e.clientX;
      const newY = e.clientY;

      setPosition({ x: newX, y: newY });

      // Check for magnetic elements
      const magneticElement = findMagneticElement(newX, newY);

      if (magneticElement) {
        const rect = magneticElement.rect;
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        // Calculate magnetic pull
        const distance = Math.sqrt(
          Math.pow(newX - centerX, 2) + Math.pow(newY - centerY, 2)
        );
        const magneticStrength = magneticElement.magneticStrength;
        const maxDistance = 50;

        if (distance < maxDistance) {
          const pullStrength = (1 - distance / maxDistance) * magneticStrength;
          const magneticX = newX + (centerX - newX) * pullStrength;
          const magneticY = newY + (centerY - newY) * pullStrength;

          setMagneticTarget({ x: magneticX, y: magneticY });
          setCursorVariant('magnetic');
          setCursorSize(40);
        } else {
          setMagneticTarget(null);
        }
      } else {
        setMagneticTarget(null);
      }

      // Set cursor position
      if (!magneticTarget) {
        cursorX.set(newX);
        cursorY.set(newY);
      }

      // Enhanced trail creation with velocity-based opacity
      const velocity = Math.sqrt(
        Math.pow(newX - position.x, 2) + Math.pow(newY - position.y, 2)
      );
      const trailOpacity = Math.min(0.8, velocity / 10);

      if (Math.random() > 0.6) {
        addTrail(newX, newY, trailOpacity);
      }

      const target = e.target as Element;

      if (target && typeof window !== 'undefined') {
        const computedStyle = window.getComputedStyle(target);
        const cursor = computedStyle.getPropertyValue('cursor');
        const isPointerCursor = cursor === 'pointer';

        // Check if hovering over text
        const isTextElement = [
          'P',
          'H1',
          'H2',
          'H3',
          'H4',
          'H5',
          'H6',
          'SPAN',
          'DIV'
        ].includes(target.tagName);
        const hasTextContent =
          target.textContent && target.textContent.trim().length > 0;

        setIsHoveringText(isTextElement && Boolean(hasTextContent));
        setIsPointer(isPointerCursor);

        if (!magneticTarget) {
          if (isPointerCursor) {
            setCursorVariant('hover');
            setCursorSize(48);
          } else if (isTextElement && hasTextContent) {
            setCursorVariant('text');
            setCursorSize(28);
          } else {
            setCursorVariant('default');
            setCursorSize(32);
          }
        }
      }
    },
    [cursorX, cursorY, addTrail, position, magneticTarget, findMagneticElement]
  );

  const handleMouseDown = useCallback(() => {
    setIsClicking(true);
    setCursorVariant('click');
    setCursorSize(24);

    // Add multiple trails on click for explosion effect
    for (let i = 0; i < 5; i++) {
      setTimeout(() => {
        addTrail(position.x, position.y, 1);
      }, i * 10);
    }
  }, [addTrail, position]);

  const handleMouseUp = useCallback(() => {
    setIsClicking(false);
    if (magneticTarget) {
      setCursorVariant('magnetic');
      setCursorSize(40);
    } else if (isPointer) {
      setCursorVariant('hover');
      setCursorSize(48);
    } else if (isHoveringText) {
      setCursorVariant('text');
      setCursorSize(28);
    } else {
      setCursorVariant('default');
      setCursorSize(32);
    }
  }, [isPointer, isHoveringText, magneticTarget]);

  useEffect(() => {
    setIsClient(true);

    if (typeof window !== 'undefined') {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mousedown', handleMouseDown);
      window.addEventListener('mouseup', handleMouseUp);

      return () => {
        window.removeEventListener('mousemove', handleMouseMove);
        window.removeEventListener('mousedown', handleMouseDown);
        window.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [handleMouseMove, handleMouseDown, handleMouseUp]);

  // Clean up old trails periodically
  useEffect(() => {
    const interval = setInterval(() => {
      setTrails((prev) =>
        prev.filter((trail) => Date.now() - trail.timestamp < 300)
      );
    }, 100);

    return () => clearInterval(interval);
  }, []);

  if (!isClient) {
    return null;
  }

  const cursorVariants = {
    default: {
      scale: 1,
      opacity: 0.8,
      rotate: 0,
      background:
        'radial-gradient(circle, rgba(14, 165, 233, 0.15) 0%, transparent 70%)',
      border: '2px solid rgba(14, 165, 233, 0.3)',
      width: 32,
      height: 32
    },
    hover: {
      scale: 1.5,
      opacity: 1,
      rotate: 180,
      background:
        'radial-gradient(circle, rgba(52, 211, 153, 0.25) 0%, rgba(14, 165, 233, 0.15) 50%, transparent 80%)',
      border: '2px solid rgba(52, 211, 153, 0.6)',
      width: 48,
      height: 48
    },
    click: {
      scale: 0.8,
      opacity: 1,
      rotate: 360,
      background:
        'radial-gradient(circle, rgba(236, 72, 153, 0.4) 0%, rgba(147, 51, 234, 0.2) 50%, transparent 80%)',
      border: '3px solid rgba(236, 72, 153, 0.8)',
      width: 24,
      height: 24
    },
    magnetic: {
      scale: 1.2,
      opacity: 1,
      rotate: 0,
      background:
        'radial-gradient(circle, rgba(255, 255, 255, 0.2) 0%, transparent 70%)',
      border: '2px solid rgba(255, 255, 255, 0.6)',
      width: 40,
      height: 40
    },
    text: {
      scale: 1.1,
      opacity: 0.9,
      rotate: 0,
      background:
        'radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%)',
      border: '2px solid rgba(255, 255, 255, 0.4)',
      width: 28,
      height: 28
    }
  };

  return (
    <>
      {/* Main Cursor */}
      <motion.div
        className="fixed pointer-events-none z-[999999] rounded-full mix-blend-screen"
        style={{
          left: springX,
          top: springY,
          x: '-50%',
          y: '-50%'
        }}
        variants={cursorVariants}
        animate={cursorVariant}
        transition={{
          type: 'spring',
          stiffness: 400,
          damping: 25,
          mass: 0.5
        }}
      >
        {/* Inner glow effect */}
        <motion.div
          className="absolute inset-0 rounded-full"
          style={{
            background:
              'radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 60%)'
          }}
          animate={{
            scale: cursorVariant === 'click' ? [1, 1.5, 1] : 1,
            opacity: cursorVariant === 'click' ? [0.5, 1, 0.5] : 0.3
          }}
          transition={{
            duration: 0.3,
            ease: 'easeInOut'
          }}
        />

        {/* Pulse effect on click */}
        <AnimatePresence>
          {isClicking && (
            <motion.div
              className="absolute inset-0 rounded-full border-2 border-pink-400"
              initial={{ scale: 0, opacity: 1 }}
              animate={{ scale: 3, opacity: 0 }}
              exit={{ scale: 4, opacity: 0 }}
              transition={{ duration: 0.6, ease: 'easeOut' }}
            />
          )}
        </AnimatePresence>
      </motion.div>

      {/* Cursor Trails */}
      <AnimatePresence>
        {trails.map((trail, index) => (
          <motion.div
            key={trail.id}
            className="fixed pointer-events-none z-[999998] rounded-full mix-blend-screen"
            style={{
              left: trail.x,
              top: trail.y,
              x: '-50%',
              y: '-50%'
            }}
            initial={{
              scale: 0.5,
              opacity: 0.6,
              background:
                'radial-gradient(circle, rgba(14, 165, 233, 0.1) 0%, transparent 60%)',
              border: '1px solid rgba(14, 165, 233, 0.2)',
              width: 16 - index * 1.5,
              height: 16 - index * 1.5
            }}
            animate={{
              scale: 0.2,
              opacity: 0
            }}
            exit={{
              scale: 0,
              opacity: 0
            }}
            transition={{
              duration: 0.3,
              ease: 'easeOut',
              delay: index * 0.02
            }}
          />
        ))}
      </AnimatePresence>

      {/* Ambient glow */}
      <motion.div
        className="fixed pointer-events-none z-[999997] rounded-full"
        style={{
          left: springX,
          top: springY,
          x: '-50%',
          y: '-50%',
          width: 120,
          height: 120,
          background:
            'radial-gradient(circle, rgba(14, 165, 233, 0.05) 0%, transparent 70%)',
          filter: 'blur(20px)'
        }}
        animate={{
          scale:
            cursorVariant === 'hover'
              ? 1.3
              : cursorVariant === 'click'
              ? 0.8
              : 1,
          opacity:
            cursorVariant === 'hover'
              ? 0.8
              : cursorVariant === 'click'
              ? 1
              : 0.4
        }}
        transition={{
          type: 'spring',
          stiffness: 300,
          damping: 30
        }}
      />
    </>
  );
};

export default FlareCursor;
